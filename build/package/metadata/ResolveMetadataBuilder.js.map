{"version":3,"sources":["../../src/metadata/ResolveMetadataBuilder.ts"],"names":[],"mappings":"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","file":"ResolveMetadataBuilder.js","sourcesContent":["import {GraphModule} from \"../options/GraphModule\";\nimport {Utils} from \"../util/Utils\";\nimport {MetadataArgsStorage} from \"../metadata-args/MetadataArgsStorage\";\nimport {ResolveMetadata} from \"./ResolveMetadata\";\nimport {ResolveMetadataArgs} from \"../metadata-args/ResolveMetadataArgs\";\nimport {GraphModuleResolverMethod} from \"../options/GraphModuleResolverMethod\";\nimport {ResolverMetadataArgs} from \"../metadata-args/ResolverMetadataArgs\";\nimport {GraphModuleResolver} from \"../options/GraphModuleResolver\";\nimport {SchemaBuilderOptions} from \"../options/SchemaBuilderOptions\";\nimport {AuthorizedMetadataArgs} from \"../metadata-args/AuthorizedMetadataArgs\";\nimport {ArgsValidatorMetadataArgs} from \"../metadata-args/ArgsValidatorMetadataArgs\";\nimport {EntitySchema} from \"typeorm\";\n\n/**\n * Builds resolve metadatas.\n */\nexport class ResolveMetadataBuilder {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected options: SchemaBuilderOptions,\n                protected metadataArgsStorage: MetadataArgsStorage) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds resolve metadatas based on the given stack options and metadata args storage.\n     */\n    build(modules: GraphModule[]): ResolveMetadata[] {\n        const resolves: ResolveMetadata[] = [];\n\n        // first load controllers\n        // thus we are filling metadata args storage\n        modules.forEach(module => {\n            if (!module.resolvers)\n                return;\n\n            const resolverDirs = module.resolvers.filter(resolver => typeof resolver === \"string\") as string[];\n            Utils.importClassesFromDirectories(resolverDirs);\n        });\n\n        // now we have all metadata args registered in the storage, first read all resolvers from the storage\n        this.metadataArgsStorage.resolvers.forEach(resolver => {\n            this.metadataArgsStorage.resolves.forEach(resolve => {\n                if (resolve.target !== resolver.target)\n                    return;\n\n                const validators = this.metadataArgsStorage.validators.filter(validator => validator.target === resolve.target && validator.methodName === resolve.methodName);\n                const authorizes = this.metadataArgsStorage.authorizes.filter(authorize => authorize.target === resolve.target && authorize.methodName === resolve.methodName);\n                resolves.push(this.createFromMetadataArgs(resolver, resolve, validators, authorizes));\n            });\n        });\n\n        // now register all resolves passed in the array of modules\n        modules.forEach(module => {\n            if (module.resolvers) {\n                module.resolvers.forEach(resolver => {\n                    if (typeof resolver === \"object\") {\n                        resolver.methods.forEach(method => {\n                            resolves.push(this.createFromModuleResolver(resolver, method));\n                        });\n                    }\n                });\n            }\n        });\n\n        return resolves;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates ResolveMetadata from the given resolver and resolve metadata args objects.\n     */\n    protected createFromMetadataArgs(resolver: ResolverMetadataArgs, resolve: ResolveMetadataArgs, validators: ArgsValidatorMetadataArgs[], authorizes: AuthorizedMetadataArgs[]): ResolveMetadata {\n        const metadata = new ResolveMetadata();\n        metadata.target = resolver.target;\n        if (resolver.name instanceof Function) {\n            metadata.name = this.options.entityResolverNamingStrategy ? this.options.entityResolverNamingStrategy(resolver.name) : resolver.name.name;\n            metadata.entity = resolver.name;\n        } else {\n            metadata.name = resolver.name;\n        }\n        metadata.methodName = resolve.methodName;\n        metadata.resolvingPropertyName = resolve.name || resolve.methodName;\n        metadata.dataLoader = resolve.dataLoader === true ? true : false;\n        metadata.validators = validators.map(validator => validator.validator);\n        metadata.authorizes = authorizes.map(authorize => authorize.roles);\n        return metadata;\n    }\n\n    /**\n     * Creates ResolveMetadata from the given GraphModule resolver and method objects.\n     */\n    protected createFromModuleResolver(resolver: GraphModuleResolver, method: GraphModuleResolverMethod|string): ResolveMetadata {\n        const metadata = new ResolveMetadata();\n        metadata.target = resolver.resolver;\n        if (resolver.model instanceof Function) {\n            metadata.name = this.options.entityResolverNamingStrategy ? this.options.entityResolverNamingStrategy(resolver.model) : resolver.model.name;\n            metadata.entity = resolver.model;\n\n        } else if (resolver.model instanceof EntitySchema) {\n            metadata.name = resolver.model.options.name;\n            metadata.entity = resolver.model;\n\n        } else {\n            metadata.name = resolver.model;\n        }\n        if (typeof method === \"string\") {\n            metadata.methodName = method;\n            metadata.resolvingPropertyName = method;\n            metadata.dataLoader = false;\n            metadata.validators = [];\n            metadata.authorizes = [];\n        } else {\n            metadata.methodName = method.methodName;\n            metadata.resolvingPropertyName = method.name || method.methodName;\n            metadata.dataLoader = method.many === true ? true : false;\n            metadata.validators = method.validators || [];\n            metadata.authorizes = method.authorizes || [];\n        }\n        return metadata;\n    }\n\n}"],"sourceRoot":".."}